#!/usr/bin/env sh

# PATH 설정 (GUI 환경에서도 git 등 명령어를 찾을 수 있도록)
export PATH="/usr/local/bin:/usr/bin:/bin:$PATH"

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2

# merge, squash, amend 등의 경우 실행하지 않음
if [ -n "$COMMIT_SOURCE" ]; then
  exit 0
fi

# 현재 브랜치명 가져오기 (실패 시 빈 문자열)
BRANCH_NAME=$(git symbolic-ref --short HEAD 2>/dev/null || echo "")

# 브랜치명이 없거나 main, master, develop 브랜치는 제외
if [ -z "$BRANCH_NAME" ] || [ "$BRANCH_NAME" = "main" ] || [ "$BRANCH_NAME" = "master" ] || [ "$BRANCH_NAME" = "develop" ]; then
  exit 0
fi

# 브랜치명 파싱: type/branch-name/issue-number/developer
# 예: feat/Todo/100/yj
IFS='/' read -r TYPE BRANCH_NAME_PART ISSUE_NUMBER DEVELOPER <<< "$BRANCH_NAME"

# 최소한 branch-name이 있어야 함
if [ -z "$BRANCH_NAME_PART" ]; then
  exit 0
fi

# 기존 커밋 메시지 읽기
COMMIT_MSG=$(cat "$COMMIT_MSG_FILE" 2>/dev/null || echo "")

# 커밋 메시지 prefix 생성: [branch-name]
PREFIX="[$BRANCH_NAME_PART] "

# 주석이 아닌 내용이 이미 있는지 확인 (git commit -m "message" 사용한 경우)
if echo "$COMMIT_MSG" | grep -q "^[^#]"; then
  # 이미 작성된 메시지가 있으면 첫 줄에 prefix만 추가
  {
    echo "$COMMIT_MSG" | sed "1s/^/$PREFIX/"
  } > "$COMMIT_MSG_FILE.tmp" 2>/dev/null
  mv "$COMMIT_MSG_FILE.tmp" "$COMMIT_MSG_FILE" 2>/dev/null

  # 이슈 번호가 있고, footer에 아직 없으면 추가
  if [ -n "$ISSUE_NUMBER" ] && ! grep -q "#$ISSUE_NUMBER" "$COMMIT_MSG_FILE"; then
    echo "" >> "$COMMIT_MSG_FILE"
    echo "#$ISSUE_NUMBER" >> "$COMMIT_MSG_FILE"
  fi
else
  # 비어있으면 템플릿 생성 (git commit 에디터 사용 시)
  # 포맷:
  # [branch-name]
  #
  # (빈 줄 - body)
  # (빈 줄 - footer)
  # #issue-number (있는 경우)
  {
    echo "$PREFIX"
    echo ""
    if [ -n "$ISSUE_NUMBER" ]; then
      echo ""
      echo ""
      echo "#$ISSUE_NUMBER"
    fi
    echo ""
    # 기존 주석 라인 유지
    echo "$COMMIT_MSG"
  } > "$COMMIT_MSG_FILE.tmp" 2>/dev/null
  mv "$COMMIT_MSG_FILE.tmp" "$COMMIT_MSG_FILE" 2>/dev/null
fi

exit 0
